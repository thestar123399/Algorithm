一、算法描述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:
输入: "()"
输出: true
示例 2:
输入: "()[]{}"
输出: true
示例 3:
输入: "(]"
输出: false
示例 4:
输入: "([)]"
输出: false
示例 5:
输入: "{[]}"
输出: true

解题思路：
算法原理
栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；
建立哈希表 dic 构建左右括号对应关系：keykey 左括号，valuevalue 右括号；这样查询 22 个括号是否对应只需 O(1)O(1) 时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。

算法流程
如果 c 是左括号，则入栈 pushpush；
否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 falsefalse。

提前返回 falsefalse
提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。

解决边界问题：
栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ?? ，并在哈希表 dic 中建立 key: '?'，value:'?'key: ′ ? ′ ，value: ′ ? ′
  的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 falsefalse；
字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。

复杂度分析
时间复杂度 O(N)：正确的括号组合需要遍历 11 遍 s；
空间复杂度 O(N)：哈希表和栈使用线性的空间大小。


C++：
class Solution {
public:
    bool isValid(string s) {
        int count = 0;
        char stack[s.length()+1];

        for(char str : s){
            if(str == '(' || str == '[' || str == '{'){
                stack[count] = str;
                count++;
            }
            else{
                count--;
                if(count < 0){
                    return false;
                }
                else{
                    if(stack[count] == '('){
                        if(str == ')') {
                            //count--;
                        }
                        else{
                            return false;
                        }
                    }
                    else if(stack[count] == '{'){
                        if(str == '}'){
                            //count--;
                        }
                        else{
                            return false;
                        }
                    }
                    else{
                        if(str == ']'){
                            //count--;
                        }
                        else{
                            return false;
                        }
                    }
                }
                
            }

        }

        if(count == 0){
            return true;
        }
        else{
            return false;
        }
    }
};
或者
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char,int> m{{'(',1},{'[',2},{'{',3},
                                {')',4},{']',5},{'}',6}};
        stack<char> st;
        bool istrue=true;
        for(char c:s){
            int flag=m[c];
            if(flag>=1&&flag<=3) st.push(c);
            else if(!st.empty()&&m[st.top()]==flag-3) st.pop();
            else {istrue=false;break;}
        }
        if(!st.empty()) istrue=false;
        return istrue;
    }
};
使用了哈希表来判断是否能够形成括号，从而决定进行入栈操作还是出栈操作。
复杂度分析
时间复杂度：O(N)。遍历了一遍字符串。
空间复杂度：O(N)。最坏情况下，假如输入是 (((((((，栈的大小将是输入字符串的长度。

Python：
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{': '}',  '[': ']', '(': ')', '?': '?'}
        stack = ['?']
        for c in s:
            if c in dic: stack.append(c)
            elif dic[stack.pop()] != c: return False 
        return len(stack) == 1

或者
class Solution:
    def isValid(self, s):
        while '{}' in s or '()' in s or '[]' in s:
            s = s.replace('{}', '')
            s = s.replace('[]', '')
            s = s.replace('()', '')
        return s == ''
        
JAVA:
class Solution {
    public boolean isValid(String s) {
        Stack<Character>stack = new Stack<Character>();
        for(char c: s.toCharArray()){
            if(c=='(')stack.push(')');
            else if(c=='[')stack.push(']');
            else if(c=='{')stack.push('}');
            else if(stack.isEmpty()||c!=stack.pop())return false;
        }
        return stack.isEmpty();
    }
}
